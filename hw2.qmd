---
title: "hw2"
format: html
editor: visual
---

## Problem1 - Modified Random walk

#version 1:using a loop
```{r}
#' 1D Modified Random Walk (Loop, Explicit Random Sequence)
#'
#' Simulates a one-dimensional random walk with probabilistic jumps, using a for-loop and 
#' explicit input of direction and decision vectors. This ensures strict reproducibility 
#' across implementations.
#'
#' @param n Integer. Number of steps.
#' @param directions Integer vector of length n. Each entry should be 1 or -1, indicating direction.
#' @param rplus Numeric vector of length n. Values in [0, 1], used for +1/+10 decisions.
#' @param rminus Numeric vector of length n. Values in [0, 1], used for -1/-3 decisions.
#' @return Integer. Final walk position.
#' @examples
#' set.seed(123)
#' n <- 10
#' directions <- sample(c(-1, 1), n, replace = TRUE)
#' rplus <- runif(n); rminus <- runif(n)
#' random_walk1_consistent(n, directions, rplus, rminus)
random_walk1_consistent <- function(n, directions, rplus, rminus) {
  pos <- 0
  for (i in 1:n) {
    if (directions[i] == 1) {
      move <- ifelse(rplus[i] < 0.05, 10, 1)
    } else {
      move <- ifelse(rminus[i] < 0.20, -3, -1)
    }
    pos <- pos + move
  }
  pos
}
```

#version 2:using vectorized R operations

```{r}
#' 1D Modified Random Walk (Vectorized, Explicit Random Sequence)
#'
#' Simulates a one-dimensional random walk with probabilistic jumps, using vectorized operations and 
#' explicit input of direction and decision vectors. Result is strictly reproducible.
#'
#' @param n Integer. Number of steps.
#' @param directions Integer vector of length n. Each entry should be 1 or -1, indicating direction.
#' @param rplus Numeric vector of length n. Values in [0, 1], used for +1/+10 decisions.
#' @param rminus Numeric vector of length n. Values in [0, 1], used for -1/-3 decisions.
#' @return Integer. Final walk position.
#' @examples
#' set.seed(123)
#' n <- 10
#' directions <- sample(c(-1, 1), n, replace = TRUE)
#' rplus <- runif(n); rminus <- runif(n)
#' random_walk2_consistent(n, directions, rplus, rminus)
random_walk2_consistent <- function(n, directions, rplus, rminus) {
  move <- ifelse(directions == 1, 
                 ifelse(rplus < 0.05, 10, 1), 
                 ifelse(rminus < 0.20, -3, -1))
  sum(move)
}

```

#version 3:using apply

```{r}
#' 1D Modified Random Walk (Apply, Explicit Random Sequence)
#'
#' Simulates a one-dimensional random walk with probabilistic jumps, using sapply and
#' explicit input of direction and decision vectors. Strictly reproducible.
#'
#' @param n Integer. Number of steps.
#' @param directions Integer vector of length n. Each entry should be 1 or -1, indicating direction.
#' @param rplus Numeric vector of length n. Values in [0, 1], used for +1/+10 decisions.
#' @param rminus Numeric vector of length n. Values in [0, 1], used for -1/-3 decisions.
#' @return Integer. Final walk position.
#' @examples
#' set.seed(123)
#' n <- 10
#' directions <- sample(c(-1, 1), n, replace = TRUE)
#' rplus <- runif(n); rminus <- runif(n)
#' random_walk3_consistent(n, directions, rplus, rminus)
random_walk3_consistent <- function(n, directions, rplus, rminus) {
  moves <- sapply(1:n, function(i) {
    if (directions[i] == 1) {
      if (rplus[i] < 0.05) 10 else 1
    } else {
      if (rminus[i] < 0.20) -3 else -1
    }
  })
  sum(moves)
}
                                       
```

#Demonstrate Equivalence(Set Seed for Reproducibility)
```{r}
set.seed(314)
n <- 1000
directions <- sample(c(-1, 1), n, replace=TRUE)
rplus <- runif(n)
rminus <- runif(n)

random_walk1_consistent(n, directions, rplus, rminus)
random_walk2_consistent(n, directions, rplus, rminus)
random_walk3_consistent(n, directions, rplus, rminus)


set.seed(42)
n <- 10
directions <- sample(c(-1, 1), n, replace=TRUE)
rplus <- runif(n)
rminus <- runif(n)

random_walk1_consistent(n, directions, rplus, rminus)
random_walk2_consistent(n, directions, rplus, rminus)
random_walk3_consistent(n, directions, rplus, rminus)

```

#Benchmarking
```{r}
library(microbenchmark)

set.seed(314)
n <- 1000
directions <- sample(c(-1, 1), n, replace = TRUE)
rplus <- runif(n)
rminus <- runif(n)

mb1 <- microbenchmark(
  rw1 = random_walk1_consistent(n, directions, rplus, rminus),
  rw2 = random_walk2_consistent(n, directions, rplus, rminus),
  rw3 = random_walk3_consistent(n, directions, rplus, rminus),
  times = 100
)
print(mb1)

# 对大数据量再来一轮
set.seed(314)
n_large <- 100000
directions <- sample(c(-1, 1), n_large, replace = TRUE)
rplus <- runif(n_large)
rminus <- runif(n_large)

mb2 <- microbenchmark(
  rw1 = random_walk1_consistent(n_large, directions, rplus, rminus),
  rw2 = random_walk2_consistent(n_large, directions, rplus, rminus),
  rw3 = random_walk3_consistent(n_large, directions, rplus, rminus),
  times = 10   # 大数据时减少重复次数
)
print(mb2)
```

#Monte Carlo Simulation for Probability of Ending at Zero
```{r}
estimate_zero_prob <- function(n, Nsim = 100000, seed = NULL) {
  if (!is.null(seed)) set.seed(seed)
  results <- replicate(Nsim, {
    directions <- sample(c(-1, 1), n, replace = TRUE)
    rplus <- runif(n)
    rminus <- runif(n)
    random_walk2_consistent(n, directions, rplus, rminus) == 0
  })
  mean(results)
}

estimate_zero_prob(10, 100000, seed = 42)   # e.g., 0.008
estimate_zero_prob(100, 100000, seed = 42)  # e.g., 0.0003
estimate_zero_prob(1000, 100000, seed = 42) # e.g., 0 (or very very small)
```
# 2
```{r}
n_sims <- 100000
hour_types <- c(
  rep("night", 8),
  "rush",
  rep("work", 8),
  "rush",
  rep("evening", 6)
)
car_mat <- sapply(seq_along(hour_types), function(hr){
  switch(hour_types[hr],
         night = rpois(n_sims, 1),
         work = rpois(n_sims, 8),
         evening = rpois(n_sims, 12),
         rush = round(rnorm(n_sims, mean=60, sd=sqrt(12)))
  )
})
mean(rowSums(car_mat))
```

```{r}
n_sims <- 1e5
day_totals <- replicate(n_sims, {
  sum(
    rpois(8, 1),
    round(rnorm(1, 60, sqrt(12))),
    rpois(8, 8),
    round(rnorm(1, 60, sqrt(12))),
    rpois(6, 12)
  )
})
mean(day_totals)
```

# 3

# Download, de-identify, and report dimensions
```{r}
# Download the data
youtube <- read.csv("https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2021/2021-03-02/youtube.csv")

# View all column names to identify potentially identifying columns
names(youtube)

# List columns that could serve as identifiers for unique commercials
id_cols <- c(
  "brand", "brand_url", "youtube_url", "channel", "channel_url",
  "date_published", "video", "description", "superbowl_ads_dot_com_url"
)

# Remove identifying columns (but keep 'year' because it's required as a predictor)
yt_deid <- youtube[, !(names(youtube) %in% id_cols)]

# Report the dimensions (rows and columns) after de-identification
dim(yt_deid)

```

# Examine and classify each engagement variable
```{r}
library(ggplot2)

# List the engagement metrics
vars <- c("view_count", "like_count", "dislike_count", "favorite_count", "comment_count")

# Plot histograms to check distribution for each variable
for (v in vars) {
  print(v)
  print(summary(yt_deid[[v]]))
  print(
    ggplot(yt_deid, aes_string(x = v)) +
      geom_histogram(bins = 30) +
      labs(title = v)
  )
}
```

#Fit regression models for appropriate outcomes
```{r}
# Prepare transformed variables for regression modeling
yt_deid$log_view_count     <- log1p(yt_deid$view_count)
yt_deid$log_like_count    <- log1p(yt_deid$like_count)
yt_deid$log_dislike_count <- log1p(yt_deid$dislike_count)
yt_deid$log_comment_count <- log1p(yt_deid$comment_count)

# List binary flag variables to use as predictors
flags <- c("funny","show_product_quickly","patriotic","celebrity","danger","animals","use_sex")

# Build regression formula for e.g., log(view_count)
formula_str <- paste("log_view_count ~", paste(flags, collapse = " + "), "+ year")
model_view <- lm(formula(formula_str), data = yt_deid)
summary(model_view)

# Do the same for other appropriate outcome variables
model_like <- lm(log_like_count ~ funny + show_product_quickly + patriotic + celebrity +
                   danger + animals + use_sex + year, data = yt_deid)
summary(model_like)

model_dislike <- lm(log_dislike_count ~ funny + show_product_quickly + patriotic + celebrity +
                      danger + animals + use_sex + year, data = yt_deid)
summary(model_dislike)

model_comment <- lm(log_comment_count ~ funny + show_product_quickly + patriotic + celebrity +
                      danger + animals + use_sex + year, data = yt_deid)
summary(model_comment)
```

#Manually compute regression coefficients for log(view_count)
```{r}
# Construct design matrix based on R's default coding (intercept included)
X <- model.matrix(~ funny + show_product_quickly + patriotic + celebrity + danger + animals + use_sex + year, yt_deid)
y <- yt_deid$log_view_count

# Compute the OLS solution: beta_hat = (X'X)⁻¹ X'y
beta_hat <- solve(t(X) %*% X) %*% t(X) %*% y

# Compare with coefficients from lm
as.numeric(beta_hat)      # Manual calculation
coef(model_view)          # From lm; should be identical (up to rounding)
```