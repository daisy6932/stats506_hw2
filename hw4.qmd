---
title: "HW3 DAIXI HUANG "
format: html
editor: visual
---

## 1

```{r}
# Install and load required packages
library(nzelect)
library(tidyverse)

glimpse(nzge)
```

#(a) Total vote count per year and vote type

```{r}
nzge %>%
  group_by(election_year, voting_type) %>%
  summarize(total_votes = sum(votes, na.rm = TRUE)) %>%
  arrange(desc(total_votes)) %>%
  ungroup()
```

#(b) Focus on 2014 Candidate vote — proportion of votes per party

```{r}
nzge %>%
  filter(election_year == 2014, voting_type == "Candidate") %>%
  group_by(party) %>%
  summarize(votes = sum(votes, na.rm = TRUE)) %>%
  mutate(percent = 100 * votes / sum(votes)) %>%
  arrange(desc(percent)) %>%
  ungroup()
```

#(c) Find which party won Candidate and Party vote per year

```{r}
nzge %>%
  group_by(election_year, voting_type, party) %>%
  summarize(total_votes = sum(votes, na.rm = TRUE)) %>%
  group_by(election_year, voting_type) %>%
  slice_max(total_votes, n = 1, with_ties = FALSE) %>%
  pivot_wider(
    names_from = voting_type,
    values_from = party,
    names_prefix = "winner_"
  ) %>%
  arrange(election_year)


```

##2

```{r}
# Load packages
library(tidyverse)

# Load 2019 ATP matches data
matches <- read_csv("https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_matches_2019.csv")

# Check structure
#glimpse(matches)
```

#(a)

```{r}
matches %>%
  distinct(tourney_id, tourney_name) %>%
  summarise(num_tournaments = n())
```

There were 128 tournaments in 2019.

#(b)

```{r}
tournament_wins <- matches %>%
  distinct(tourney_id, winner_name) %>%
  group_by(winner_name) %>%
  summarise(tournaments_won = n()) %>%
  arrange(desc(tournaments_won))

# Show those who won more than one tournament
tournament_wins %>%
  filter(tournaments_won > 1) %>%
  summarise(
    num_players_multi = n(),
    max_tournaments = max(tournaments_won)
  )
```

155 players won more than one tournament, and the top players won 21 tournaments.

#(c)

```{r}

aces <- matches %>%
  select(w_ace, l_ace) %>%
  pivot_longer(everything(), names_to = "role", values_to = "aces") %>%
  mutate(role = if_else(role == "w_ace", "Winner", "Loser"))

# Compute summary statistics
aces %>%
  group_by(role) %>%
  summarise(
    mean_aces = mean(aces, na.rm = TRUE),
    median_aces = median(aces, na.rm = TRUE),
    n = sum(!is.na(aces))
  )

# Hypothesis test using tidyverse-compatible package
library(infer)

obs_stat <- aces %>%
  specify(aces ~ role) %>%              
  calculate(stat = "diff in means", order = c("Winner", "Loser")) %>%
  pull(stat)

obs_stat

set.seed(2025) 
null_dist <- aces %>%
  specify(aces ~ role) %>%
  hypothesize(null = "independence") %>%     
  generate(reps = 5000, type = "permute") %>%
  calculate(stat = "diff in means", order = c("Winner", "Loser"))


p_value <- null_dist %>%
  summarise(p = mean(stat >= obs_stat)) %>%
  pull(p)

p_value

null_dist %>%
  ggplot(aes(x = stat)) +
  geom_histogram(bins = 60) +
  geom_vline(xintercept = obs_stat, color = "red") +
  labs(title = "Permutation null distribution: diff in means (Winner - Loser)",
       subtitle = paste0("observed diff = ", round(obs_stat, 3), ", p = ", signif(p_value, 3)),
       x = "Difference in means", y = "Count")

```

From the summary statistics, winners averaged 7.50 aces per match (median = 6), while losers averaged 5.79 aces per match (median = 4). Both groups had data from 2,694 observations.

The permutation test (with 5,000 replicates) produced an observed difference in means of 1.705 aces (Winner − Loser) and a p-value ≈ 0. This indicates that, under the null hypothesis of no difference in average aces between winners and losers, it is extremely unlikely to observe such a large difference by random chance.

Therefore, we reject the null hypothesis and conclude that there is strong statistical evidence that match winners serve significantly more aces than losers in the 2019 ATP data.

#(d)

```{r}
player_stats <- matches %>%
  # count wins
  count(winner_name, name = "wins") %>%
  rename(player = winner_name) %>%
  full_join(
    matches %>%
      count(loser_name, name = "losses") %>%
      rename(player = loser_name),
    by = "player"
  ) %>%
  replace_na(list(wins = 0, losses = 0)) %>%
  mutate(
    total_matches = wins + losses,
    win_rate = wins / total_matches
  )

# Filter for players with ≥5 matches and sort by win rate
player_stats %>%
  filter(total_matches >= 5) %>%
  arrange(desc(win_rate)) %>%
  head(10)
```

Among players with \>= matches, Rafael Nadal had the highest win rate.

##3

```{r}
# ---- Setup ----
# Install packages if you don't have them (uncomment if needed)
# install.packages(c("tidyverse", "scales", "lubridate", "pracma", "viridis"))

library(tidyverse)
library(lubridate)
library(scales)
library(pracma)   # for findpeaks()
library(ggrepel)     # nicer labels on plots
library(viridis)  # nice color palette

# ---- 1. Load data ----
url <- "https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv"
df <- read_csv(url, col_types = cols())

# Inspect
glimpse(df)
# Expect columns like: date, state, cases, cases_avg, cases_avg_per_100k, deaths, deaths_avg, deaths_avg_per_100k

states <- read_csv(url,
                   col_types = cols(
                     date = col_date(format = ""),
                     geoid = col_character(),
                     state = col_character(),
                     cases = col_double(),
                     cases_avg = col_double(),
                     cases_avg_per_100k = col_double(),
                     deaths = col_double(),
                     deaths_avg = col_double(),
                     deaths_avg_per_100k = col_double()
                   ))

```

```{r}
# helper: detect local maxima (simple approach)
is_local_peak <- function(x, span = 7) {
  # returns logical vector same length as x indicating local maxima within +/- floor(span/2)
  n <- length(x)
  s <- floor(span/2)
  map_lgl(seq_along(x), ~{
    i <- .x
    if (is.na(x[i])) return(FALSE)
    left <- max(1, i - s)
    right <- min(n, i + s)
    all(x[i] >= x[left:right], na.rm = TRUE) && any(x[i] > x[left:right], na.rm = TRUE)
  })
}

# find peaks per state
peaks <- states %>%
  arrange(state, date) %>%
  group_by(state) %>%
  mutate(is_peak = is_local_peak(cases_avg_per_100k, span = 15)) %>%  # span tuned for ~2-week window
  filter(is_peak) %>%
  ungroup()

# classify peak sizes across all peaks
peak_thresholds <- quantile(peaks$cases_avg_per_100k, probs = c(0.60, 0.90), na.rm = TRUE)
peaks <- peaks %>%
  mutate(size = case_when(
    cases_avg_per_100k >= peak_thresholds[2] ~ "major",
    cases_avg_per_100k >= peak_thresholds[1] ~ "minor",
    TRUE ~ "small"
  ))

# summary counts (how many major/minor peaks total across all states)
peaks_summary <- peaks %>%
  count(size) %>%
  arrange(desc(n))

# plot: US median trajectory + vertical rugs at aggregated major/minor peak dates
us_median <- states %>%
  group_by(date) %>%
  summarize(median_cases_per_100k = median(cases_avg_per_100k, na.rm = TRUE),
            p90 = quantile(cases_avg_per_100k, 0.90, na.rm = TRUE),
            p10 = quantile(cases_avg_per_100k, 0.10, na.rm = TRUE)) %>%
  ungroup()

agg_peaks <- peaks %>%
  group_by(date, size) %>%
  summarize(n_states = n(), .groups = "drop")

p1 <- ggplot(us_median, aes(x = date, y = median_cases_per_100k)) +
  geom_ribbon(aes(ymin = p10, ymax = p90), alpha = 0.15) +
  geom_line(size = 1) +
  geom_segment(data = agg_peaks %>% filter(size == "major"),
               aes(x = date, xend = date, y = 0, yend = 0.9 * max(us_median$median_cases_per_100k, na.rm = TRUE)),
               color = "red", alpha = 0.6) +
  geom_segment(data = agg_peaks %>% filter(size == "minor"),
               aes(x = date, xend = date, y = 0, yend = 0.55 * max(us_median$median_cases_per_100k, na.rm = TRUE)),
               color = "orange", alpha = 0.5) +
  scale_y_continuous(name = "Median 7-day avg cases per 100k",
                     labels = scales::label_number(accuracy = 0.1)) +
  labs(title = "US median trajectory of 7-day avg cases per 100k with aggregated peaks",
       subtitle = "Red vertical lines = aggregated 'major' peaks (top 10% of peak heights across states); orange = 'minor' peaks",
       x = NULL, caption = "Data: NYTimes rolling-averages (states).") +
  theme_minimal()

p1
```

The plot shows the national median 7-day average of new Covid cases per 100,000 residents from 2020 through 2023. The orange and red vertical lines mark local peaks detected across all states, with red indicating the “major” spikes (the top 10% of peak magnitudes).

From the plot, we can identify approximately five major waves of Covid in the United States:

The initial outbreak in early 2020,

The winter 2020–2021 surge,

The Delta wave (mid-2021),

The Omicron wave (late 2021–early 2022), and

A smaller rebound in mid-2022.

Minor spikes occur frequently in between, reflecting regional resurgences. The aggregated national trajectory captures both the recurring pattern of resurgence and the overall downward trend in late 2022–2023.

```{r}
state_summary <- states %>%
  group_by(state) %>%
  summarize(mean_rate = mean(cases_avg_per_100k, na.rm = TRUE),
            max_rate = max(cases_avg_per_100k, na.rm = TRUE),
            .groups = "drop")

top_states <- state_summary %>% slice_max(mean_rate, n = 3) %>% pull(state)
bottom_states <- state_summary %>% slice_min(mean_rate, n = 3) %>% pull(state)
sel_states <- c(top_states, bottom_states)

p2 <- states %>%
  filter(state %in% sel_states) %>%
  ggplot(aes(x = date, y = cases_avg_per_100k, color = state)) +
  geom_line(size = 1) +
  facet_wrap(~ state, ncol = 2, scales = "free_y") +   # free_y helps see shapes even if magnitudes differ
  labs(title = "Trajectories of 7-day avg cases per 100k in highest vs lowest rate states",
       subtitle = paste("Top:", paste(top_states, collapse = ", "), 
                        " | Bottom:", paste(bottom_states, collapse = ", ")),
       y = "7-day avg cases per 100k", x = NULL,
       caption = "Top/bottom determined by mean 7-day avg per 100k across full period.") +
  theme_minimal() +
  theme(legend.position = "none")

p2

```

The figure compares states with the highest mean case rates (American Samoa, Rhode Island, Alaska) and those with the lowest (Maryland, Maine, Oregon).

High-rate states show sharp, tall peaks with brief but intense outbreaks. For instance, Rhode Island and American Samoa experienced extreme but short-lived spikes.

Low-rate states display flatter trajectories, indicating steadier case control or smaller population outbreaks.

This contrast suggests that the epidemic intensity varied dramatically by region—possibly reflecting differences in population density, testing availability, and containment policies.

```{r}
threshold <- 0.5 # daily 7-day avg per 100k; adjust if you prefer stricter definition

first_substantial <- states %>%
  arrange(state, date) %>%
  group_by(state) %>%
  mutate(above = cases_avg_per_100k >= threshold,
         # run-length encoding trick: find runs of > = threshold
         run_id = rle_id <- with(rle(above), rep(seq_along(lengths), lengths))) %>%
  group_by(state, run_id) %>%
  mutate(run_length = n()) %>%
  ungroup() %>%
  filter(above & run_length >= 3) %>%   # sustained at least 3 consecutive days
  group_by(state) %>%
  summarize(first_date = min(date, na.rm = TRUE), .groups = "drop") %>%
  arrange(first_date) %>%
  slice_head(n = 5)

first_substantial
```
