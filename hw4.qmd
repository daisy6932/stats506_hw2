---
title: "HW4 DAIXI HUANG https://github.com/daisy6932/stats506_hw2"
format: html
editor: visual
---

## 1

```{r}
# Install and load required packages
library(nzelect)
library(tidyverse)

glimpse(nzge)
```

#(a) Total vote count per year and vote type

```{r}
nzge %>%
  group_by(election_year, voting_type) %>%
  summarize(total_votes = sum(votes, na.rm = TRUE)) %>%
  arrange(desc(total_votes)) %>%
  ungroup()
```

#(b) Focus on 2014 Candidate vote — proportion of votes per party

```{r}
nzge %>%
  filter(election_year == 2014, voting_type == "Candidate") %>%
  group_by(party) %>%
  summarize(votes = sum(votes, na.rm = TRUE)) %>%
  mutate(percent = 100 * votes / sum(votes)) %>%
  arrange(desc(percent)) %>%
  ungroup()
```

#(c) Find which party won Candidate and Party vote per year

```{r}
nzge %>%
  group_by(election_year, voting_type, party) %>%
  summarize(total_votes = sum(votes, na.rm = TRUE)) %>%
  group_by(election_year, voting_type) %>%
  slice_max(total_votes, n = 1, with_ties = FALSE) %>%
  pivot_wider(
    names_from = voting_type,
    values_from = party,
    names_prefix = "winner_"
  ) %>%
  arrange(election_year)


```

##2

```{r}
# Load packages
library(tidyverse)

# Load 2019 ATP matches data
matches <- read_csv("https://raw.githubusercontent.com/JeffSackmann/tennis_atp/refs/heads/master/atp_matches_2019.csv")

# Check structure
glimpse(matches)
```

#(a)

```{r}
matches %>%
  distinct(tourney_id, tourney_name) %>%
  summarise(num_tournaments = n())
```

Although the dataset contains some tournaments with tourney_date = 20181231, these belong to the 2019 ATP season (the file atp_matches_2019.csv records all tournaments for the 2019 season, including late-December starts). Therefore, we include them when counting tournaments in 2019. The total number of tournaments in the 2019 ATP season is r n_tournaments\$n.

There were 128 tournaments in 2019.

#(b)

```{r}
winners_by_tourney <- matches %>%
  filter(round == "F") %>%
  transmute(tourney_id, tourney_name, winner_id, winner_name)

wins_per_player <- winners_by_tourney %>%
  count(winner_id, winner_name, name = "tournaments_win") %>%
  arrange(desc(tournaments_win))

more_than_one <- wins_per_player %>%
  filter(tournaments_win > 1) %>%
  nrow()

max_win <- wins_per_player %>%
  summarise(max_win = max(tournaments_win)) %>%
  pull(max_win)

most_winners <- wins_per_player %>%
  filter(tournaments_win == max_win)

more_than_one
max_win
most_winners
```

12 players won more than one tournament, and the top players won 5 tournaments.(Novak Djokovic & Dominic Thiem)

#(c)

```{r}

aces <- matches %>%
  select(w_ace, l_ace) %>%
  pivot_longer(everything(), names_to = "role", values_to = "aces") %>%
  mutate(role = if_else(role == "w_ace", "Winner", "Loser"))

# Compute summary statistics
aces %>%
  group_by(role) %>%
  summarise(
    mean_aces = mean(aces, na.rm = TRUE),
    median_aces = median(aces, na.rm = TRUE),
    n = sum(!is.na(aces))
  )

# Hypothesis test using tidyverse-compatible package
library(infer)

obs_stat <- aces %>%
  specify(aces ~ role) %>%              
  calculate(stat = "diff in means", order = c("Winner", "Loser")) %>%
  pull(stat)

obs_stat

set.seed(2025) 
null_dist <- aces %>%
  specify(aces ~ role) %>%
  hypothesize(null = "independence") %>%     
  generate(reps = 5000, type = "permute") %>%
  calculate(stat = "diff in means", order = c("Winner", "Loser"))


p_value <- null_dist %>%
  summarise(p = mean(stat >= obs_stat)) %>%
  pull(p)

p_value

null_dist %>%
  ggplot(aes(x = stat)) +
  geom_histogram(bins = 60) +
  geom_vline(xintercept = obs_stat, color = "red") +
  labs(title = "Permutation null distribution: diff in means (Winner - Loser)",
       subtitle = paste0("observed diff = ", round(obs_stat, 3), ", p = ", signif(p_value, 3)),
       x = "Difference in means", y = "Count")

```

From the summary statistics, winners averaged 7.50 aces per match (median = 6), while losers averaged 5.79 aces per match (median = 4). Both groups had data from 2,694 observations.

The permutation test (with 5,000 replicates) produced an observed difference in means of 1.705 aces (Winner − Loser) and a p-value ≈ 0. This indicates that, under the null hypothesis of no difference in average aces between winners and losers, it is extremely unlikely to observe such a large difference by random chance.

Therefore, we reject the null hypothesis and conclude that there is strong statistical evidence that match winners serve significantly more aces than losers in the 2019 ATP data.

#(d)

```{r}
player_stats <- matches %>%
  # count wins
  count(winner_name, name = "wins") %>%
  rename(player = winner_name) %>%
  full_join(
    matches %>%
      count(loser_name, name = "losses") %>%
      rename(player = loser_name),
    by = "player"
  ) %>%
  replace_na(list(wins = 0, losses = 0)) %>%
  mutate(
    total_matches = wins + losses,
    win_rate = wins / total_matches
  )

# Filter for players with ≥5 matches and sort by win rate
player_stats %>%
  filter(total_matches >= 5) %>%
  arrange(desc(win_rate)) %>%
  head(10)
```

Among players with \>= matches, Rafael Nadal had the highest win rate.

##3

```{r}
# ---- Setup ----
# Install packages if you don't have them (uncomment if needed)
# install.packages(c("tidyverse", "scales", "lubridate", "pracma", "viridis"))

library(tidyverse)
library(lubridate)
library(scales)
library(pracma)   # for findpeaks()
library(ggrepel)     # nicer labels on plots
library(viridis)  # nice color palette

# ---- 1. Load data ----
url <- "https://raw.githubusercontent.com/nytimes/covid-19-data/refs/heads/master/rolling-averages/us-states.csv"
df <- read_csv(url, col_types = cols())

# Inspect
glimpse(df)
# Expect columns like: date, state, cases, cases_avg, cases_avg_per_100k, deaths, deaths_avg, deaths_avg_per_100k

states <- read_csv(url,
                   col_types = cols(
                     date = col_date(format = ""),
                     geoid = col_character(),
                     state = col_character(),
                     cases = col_double(),
                     cases_avg = col_double(),
                     cases_avg_per_100k = col_double(),
                     deaths = col_double(),
                     deaths_avg = col_double(),
                     deaths_avg_per_100k = col_double()
                   ))

```

#(a)

```{r}
# --- Helper function: detect local peaks ---
is_local_peak <- function(x, span = 7) {
  n <- length(x)
  s <- floor(span / 2)
  map_lgl(seq_along(x), ~{
    i <- .x
    if (is.na(x[i])) return(FALSE)
    left <- max(1, i - s)
    right <- min(n, i + s)
    all(x[i] >= x[left:right], na.rm = TRUE) && any(x[i] > x[left:right], na.rm = TRUE)
  })
}

# --- Detect peaks per state ---
peaks <- states %>%
  arrange(state, date) %>%
  group_by(state) %>%
  mutate(is_peak = is_local_peak(cases_avg_per_100k, span = 15)) %>%  # 15 more smooth
  filter(is_peak) %>%
  ungroup()

# --- Classify peak sizes ---
peak_thresholds <- quantile(peaks$cases_avg_per_100k, probs = c(0.60, 0.90), na.rm = TRUE)

peaks <- peaks %>%
  mutate(size = case_when(
    cases_avg_per_100k >= peak_thresholds[2] ~ "major",
    cases_avg_per_100k >= peak_thresholds[1] ~ "minor",
    TRUE ~ "small"
  ))

# --- Summarize US-level median and quantiles ---
us_median <- states %>%
  group_by(date) %>%
  summarize(
    median_cases_per_100k = median(cases_avg_per_100k, na.rm = TRUE),
    p90 = quantile(cases_avg_per_100k, 0.90, na.rm = TRUE),
    p10 = quantile(cases_avg_per_100k, 0.10, na.rm = TRUE),
    .groups = "drop"
  )

# --- Aggregate peaks by date ---
agg_peaks <- peaks %>%
  group_by(date, size) %>%
  summarize(n_states = n(), .groups = "drop")

# --- Filter only peaks where >= 5 states reached a peak that day ---
agg_peaks_filtered <- agg_peaks %>%
  filter(n_states >= 5)

# --- Create final plot ---
p1 <- ggplot(us_median, aes(x = date, y = median_cases_per_100k)) +
  # Ribbon for middle 80% of states
  geom_ribbon(aes(ymin = p10, ymax = p90), fill = "grey70", alpha = 0.2) +
  # Median curve
  geom_line(color = "steelblue", linewidth = 1) +
  # Smooth trend (loess)
  geom_smooth(se = FALSE, color = "blue", span = 0.15,
              linewidth = 1.1, linetype = "longdash") +
  # Major peak lines
  geom_segment(data = agg_peaks_filtered %>% filter(size == "major"),
               aes(x = date, xend = date,
                   y = 0, yend = 0.9 * max(us_median$median_cases_per_100k, na.rm = TRUE)),
               color = "red", alpha = 0.4, linewidth = 0.8) +
  # Minor peak lines
  geom_segment(data = agg_peaks_filtered %>% filter(size == "minor"),
               aes(x = date, xend = date,
                   y = 0, yend = 0.55 * max(us_median$median_cases_per_100k, na.rm = TRUE)),
               color = "orange", alpha = 0.3, linewidth = 0.6) +
  scale_y_continuous(
    name = "Median 7-day avg cases per 100k",
    labels = scales::label_number(accuracy = 0.1)
  ) +
  labs(
    title = "Four Major U.S. COVID-19 Waves with Smaller Local Peaks",
    subtitle = "Blue dashed line = smoothed median trend | Red = major peaks | Orange = minor peaks\nRibbon shows 10th–90th percentile of state case rates",
    x = NULL,
    caption = "Data: NYTimes rolling-averages (us-states.csv)"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(color = "grey25", size = 12),
    panel.grid.minor = element_blank(),
    plot.caption = element_text(size = 10, color = "grey40"),
    axis.title.y = element_text(margin = margin(r = 10))
  )

p1

```

The figure visualizes the median 7-day average COVID-19 case rate per 100,000 people across U.S. states from 2020 to 2023, highlighting major and minor pandemic waves.

Blue dashed line: a smoothed national median trend of COVID-19 case rates, representing the typical U.S. state’s experience over time.

Gray ribbon (10th–90th percentile): shows the variation among states — at each date, 80% of states fell within this band. Wider ribbons indicate greater regional divergence in infection rates.

Red vertical lines: mark major peaks (top 10% of all detected state-level peaks), corresponding to large nationwide waves. These typically align with known pandemic surges — e.g., winter 2020–21, Delta (mid-2021), Omicron (winter 2021–22).

Orange bands: mark minor peaks (between 60th and 90th percentile of peak sizes), reflecting smaller, regionally contained waves.

The plot identifies four major U.S. COVID-19 waves, each separated by smaller local peaks, illustrating how the pandemic became more regionally heterogeneous over time.

Interpretation summary: The U.S. experienced four nationwide COVID-19 waves, with the Omicron surge (early 2022) being the highest median infection rate. Afterward, minor localized peaks continued but at much lower national intensity, suggesting both improved immunity and regional variation in later phases.

#(b)

```{r}
state_summary <- states %>%
  group_by(state) %>%
  summarize(mean_rate = mean(cases_avg_per_100k, na.rm = TRUE),
            max_rate = max(cases_avg_per_100k, na.rm = TRUE),
            .groups = "drop")

top_states <- state_summary %>%
  slice_max(mean_rate, n = 3) %>%
  pull(state)

bottom_states <- state_summary %>%
  slice_min(mean_rate, n = 3) %>%
  pull(state)

sel_states <- c(top_states, bottom_states)


top_states
bottom_states


p2 <- states %>%
  filter(state %in% sel_states) %>%
  ggplot(aes(x = date, y = cases_avg_per_100k, color = state)) +
  geom_line(size = 1) +
  geom_smooth(se = FALSE, linetype = "dashed", size = 0.8, color = "black") +
  facet_wrap(~ state, ncol = 2, scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  labs(
    title = "COVID-19 Case Trajectories in States with Highest vs Lowest Average Rates",
    subtitle = paste(
      "Top 3 states:", paste(top_states, collapse = ", "),
      " | Bottom 3 states:", paste(bottom_states, collapse = ", ")
    ),
    y = "7-day average cases per 100k residents",
    x = NULL,
    caption = "Data: NYTimes COVID-19 rolling averages (us-states.csv)\nDashed line = smoothed local trend"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "none",
    strip.text = element_text(face = "bold", size = 13),
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    axis.text = element_text(size = 11)
  )

p2

```

The figure compares states with the highest mean case rates (American Samoa, Rhode Island, Alaska) and those with the lowest (Maryland, Maine, Oregon).

High-rate states show sharp, tall peaks with brief but intense outbreaks. For instance, Rhode Island and American Samoa experienced extreme but short-lived spikes.

Low-rate states display flatter trajectories, indicating steadier case control or smaller population outbreaks.

This contrast suggests that the epidemic intensity varied dramatically by region—possibly reflecting differences in population density, testing availability, and containment policies. #(c)

```{r}
threshold <- 1  # define “substantial”
min_days <- 3   # at least 3 consecutive days

first_substantial <- states %>%
  arrange(state, date) %>%
  group_by(state) %>%
  mutate(
    above = cases_avg_per_100k >= threshold,
    # run-length ID per state
    run_id = with(rle(above), rep(seq_along(lengths), lengths))
  ) %>%
  group_by(state, run_id) %>%
  mutate(run_length = n()) %>%
  ungroup() %>%
  filter(above & run_length >= min_days) %>%   # sustained at least 3 consecutive days
  group_by(state) %>%
  summarize(first_date = min(date), .groups = "drop") %>%
  arrange(first_date) %>%
  slice_head(n = 5)

first_substantial
```
